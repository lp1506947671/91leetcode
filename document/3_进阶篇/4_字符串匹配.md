# 字符串匹配专题

字符串匹配算法（String matching algorithms）是字符串问题下的一个**搜索问题**，因此它本质是一个搜索问题，不过和我们前面讲的 BFS，DFS ， 回溯不太一样，这些侧重的是对搜索树进行搜索，即状态空间是非线性的。而本章的状态空间是线性的。

## 什么是字符串匹配

字符串匹配用来在一长字符串或文章中，找出其是否包含某一个或多个字符串以及其位置的算法。该算法的应用非常广泛，比如：生物基因匹配、信息检索（比如编辑器的 ctrl + f 搜索功能）等。

用数学语言描述如下:

假设TT是一个长度为nn的文本串，PP是长度为mm的模式串。如果有 0<=s<n-m0<=s<n−m，使得T[s, s+1,...,s+m-1]T[s,s+1,...,s+m−1]等于PP，则称PP在TT中出现且位移为ss。

比如 T 为 "lucifer"， "lu"（开始位置为 0）， "cifer"（开始位置为 2） 在 T 中出现过。而 "xifa"， "hello" 等没有在 T 中出现过。

## 字符串匹配常见算法

### 暴力(Brute Force)

在日常编码生活中，我们肯定会遇到类似的问题，大部分数据量其实**不大**，串长也**较短**，因此自然会想到**窗口大小固定的滑动窗口**找出所有子串并依次和模式串按字母顺序依次比对看是否匹配并记录。

> 这里的窗口大小就是模式串的长度

Brute Force 有时候也简称为 BF。其核心思路非常朴素。该算法可以抽象为以下几步：

1. 

   非法情况处理，如模式串长度大于待匹配串等（防御性编程)

   

2. 

   初始化大小为模式串长的滑窗

   

3. 

   固定当前窗口，将当前窗口的子串与模式串匹配

   2.1. 若匹配成功，则记录相关信息，如该位置下标

   2.2. 否则窗口向后移动一格

   

**伪代码**

```
n = length[T]
m = length[P]

for s = 0 to n - m
  do if T[s..s+m] == P
    save info
```

时间复杂度O(n*m)O(n∗m), 空间复杂度O(1)O(1)

这种暴力算法对于数据规模小，串短的问题已经足够了，但是很多场景下数据规模很大，那暴力算法就显得捉襟见肘了，毕竟时间复杂度摆在那里，响应时间过长。

我们稍加分析其实不难发现，我们在每次窗口后移一位进行匹配的时候，实际上是把**上一个窗口的所有状态信息全部都丢掉不要了**，这会造成信息的浪费，那么都有哪些常见且优秀的解决方案呢？

核心其实还是前面讲滑动窗口提到的**变化仅仅是窗口边缘，窗口中间不变**。这就是 RK 算法的本质。

### Rabin-Karp 算法(RK)

**这个方法是本节最最推荐掌握的一个方法。其他方法可以不掌握，但这个解法务必掌握。**

**核心思路**

RK 算法主要是对TT中每个长度为mm的子字符串T[s..s+m]T[s..s+m]进行 hash 运算，生成 hash 值h1h1，对PP进行 hash 运算，生成 hash 值h2h2, 比对h1h1和h2h2，如果两个 hash 值( 不考虑冲突)相等，则判断PP在TT中出现，且位移为ss。

该算法需要对 P 计算一次哈希，并对 T 计算 n - m + 1 次哈希。而计算哈希的复杂度和**被计算哈希的字符串**长度线性相关，每步 hash 的时间复杂度为O(m)O(m)。 在这里被计算哈希的字符串长度为 m，因此**如果仅仅使用哈希，而不对算法进行任何其他优化的话**总的时间复杂度和前面提到的暴力法一样，最后的整体复杂度和 BF 一样都为O(m*n)O(m∗n)。

RK 算法妙在滑动窗口的时候，设计了一个适合的哈希函数，有效保留了上一个状态的部分信息，这样**第一次**计算子串 hash 值时间复杂度为O(m)O(m)，而**后续就可以达到O(1)O(1)**。RK 算法最终的时间复杂度就降为O(m+n)O(m+n)。

这就是**有效利用了前面计算的窗口信息，而不是全盘计算。这不就是滑动窗口的精髓么？**。

该方法可以抽象为以下几步：

1. 

   非法情况处理，如模式串长度大于待匹配串等（防御性编程）

   

2. 

   计算出模式串 hash 值

   

3. 

   初始化大小为模式串长的滑窗并计算出 hash 值，判断当前 hash 值是否和模式串 hash 值相等。

   2.1. 若相等，则记录相关信息，如该位置下标

   2.2. 否则窗口向后移动一格，并再次计算 hash 值（此处利用上个状态可直接一步计算）

   

**伪代码**

```
n = length[T]
m = length[P]
hp = hash(P)

for s = 0 to n - m
  hs = hash(T[s..s+m])
  if hp == hs and double check is right
    save info
```

![img](https://p.ipic.vip/5lsaam.jpg)示意图

我们这里选取的哈希函数为：f(P)=P表示的10进制值f(P)=P表示的10进制值。

> 接下来的题目中，哈希函数可能会有所不同，比如 26 进制值来计算仅含 26 个英文字母的字符串的哈希。

假设PP和TT全由dd个字符组成的（也就是说字符集大小为 d），则我们可以选择dd进制表示PP和TT，再将dd进制转为1010进制便于计算。

为了简化说明，我们更特殊地假设PP和TT全由[0-9]10 个数字组成。

PP的 10 进制为：

```
f(P) = P[0] * 10 ^ (m - 1) + P[1] * 10 ^ (m - 2) ... + P[m-1]*10^0
```

接下来，我们代入上面的哈希函数计算 T 的所有子串的哈希值。

T[s..s+m]T[s..s+m]的 10 进制为:

```
f(T[s..s + m]) = T[s] * 10 ^ (m - 1) + T[s + 1] * 10 ^ (m - 2) ... + T[s + m - 1]
```

相应地，下一个字符串T[s+1..s+m]T[s+1..s+m]的哈希值可以根据前面计算好的T[s..s+m-1]T[s..s+m−1]的哈希值推导出来。即**加上窗口中新增加的字符的哈希值贡献，再减去窗口中移除的字符的哈希值贡献**

该哈希算法是将字符串的每一个位的字符转换成对应的数字，再根据一定的权重（这里是 10）相乘得到一个数值。

具体过程如下：

```
f(T[s+1..s + m]) = T[s+1] * 10 ^ (m - 1) + T[s + 2] * 10 ^ (m - 2) ... + T[s + m]
= (f(T[s..s + m]) - T[s] * 10 ^ (m - 1)) * 10 + T[s + m ]
```

这样就把以上 `hp === hs` 的哈希比较转化为正常的 10 进制比较。

到目前为止，以上假设我们回避的一个问题是如果f(P)f(P)或者f(T)f(T)计算的 10 进制过大，导致**运算溢出**怎么办？比如我们用 32 位整形存储哈希值，那么如果计算的哈希值超过了 32 位整形所能表示的上限怎么办？

即使在 Python 等支持大数的语言，我们不会遇到溢出问题。这种算法同样有问题，因为这种算法性能会随着计算的哈希值变大而降低。

如何解决溢出和性能问题呢？

这里我们通过选择一个比较大的素数qq, 计算后的 10 进制数对qq**取模后**再进行比较。 由于我们使用对 q 取模，因此理论上来必然会有冲突的情况，并且冲突的平均个数 n/q。

取模的作用是防止溢出以及提供性能。但是有冲突的可能，f(P)%q==f(T[s])%qf(P)并不能代表f(P)==f(T[s])f(P)==f(T[s])。因此任何的f(P)%q===f(T[s])%qf(P)都需要额外进行再次验证, 这里我们通过检测P==T[s..s+m]P==T[s..s+m]来完成。

从这里有可以看出，如果我们的代码冲突很多，那么效率和暴力法相差无几。极端情况，每次都哈希冲突，那么算法效率和暴力解一样，如果算法计算哈希值的开销，那么效率会比暴力法更差。

因此设计一个好的哈希算法，减少冲突是关键。如果你是参加面试或者比赛则可以尝试不同的模数来**调参**，直到通过所有的测试用例。不过这种做法非常不建议在工程中使用，即使在面试中，也希望你能先和面试官进行沟通之后再做决定。

常见的比较大的素数为 ${10**9 + 7}，为了提高性能可以选取更小的素数。

题目推荐：

- [5803. 最长公共子路径](https://leetcode-cn.com/problems/longest-common-subpath/)

总的来说，RK 算法就是：哈希函数 + 滑动窗口。使用哈希函数使得我们后续可以在 O(1)O(1) 的时间计算字符串的哈希值。

扩展：

- 如果匹配 T 的任意一段字符串。我们可以用结合前缀和的技巧来完成。`prefix[i] = prefix[i-1] * base + s[i]`， 这样子串 s[i:j] 的前缀就是 `prefix[j] - prefix[i-1] * base ** (j - i + 1)`。 推荐题目 [6036. 构造字符串的总得分和](https://leetcode-cn.com/problems/sum-of-scores-of-built-strings/)

### KMP

> 建议先观看文末扩展部分的视频后再来读讲义。

**KMP 本质上是个预处理 + dp。**

- 预处理指的是经过这样的处理一个模式串会生成一个 **唯一的 next 数组**，从而可以去匹配任意的主串。

> 唯一指的是给定模式串，生成的 next 数组就是确定的。和主串是没有任何关系的。

- dp 指的是建立 next 数组的部分使用到了动态规划的算法。

而匹配的过程，暴力（BF）算法中主串会有很多回溯，使用 KMP 可以**避免主串回溯，而只回溯模式串**。 形象地看就是模式串不停地在对齐主串。

**核心思路**

首先我们定义模式串的前缀函数 f(i) 为 模式串 P 中 P[1...i]相同前缀后缀的最大长度。对 P[1...m]中的每个 i，(i > 0 && i <= m), 用一个数组 next 记录。 KMP 算法由 Knuth，Morris 和 Pratt 三个大佬联合发明，KMP 算法名字由三个大佬名字首位字符组成。

首先我们定义模式串的函数f(i)f(i)为模式串PP中P[:i]P[:i]相同前缀后缀的最大长度。对PP中的每个ii的信息，用一个数组nextnext统一记录。 KMP 算法在每次失配后，会根据上一次的比对信息跳转到相应的ss处，借助的就是上述的nextnext数组。推导过程可以参考 [从头到尾彻底理解 KMP](https://blog.csdn.net/v_JULY_v/article/details/7041827)，个人觉得这篇讲的非常透彻，这里就不班门弄斧了。该方法可以抽象为以下几步：

- 非法情况处理，如模式串长度大于待匹配串等（防御性编程）
- 计算出模式串的 next 数组。
- 开始从待匹配串开始进行匹配
- 若匹配成功，则记录相关信息；若失配，则按 next 数组回退到上一个待匹配状态继续进行匹配

以下是计算nextnext数组的伪代码

```
get_next(P):
  m  = P.length
  使得 next 为长度为m的数组
  next[1] = 0
  k = 0
  for i = 2 to m
    while(k > 0 并且 P[k+1] != P[i])
      k = next[k]
    if P[k+1] == P[i]
      k = k + 1
    next[i] = k
  return next
```

以下是 KMP 的伪代码

```
KMP(T, P)
  n = T.length
  m = P.length
  next = getNext(P)
  q = 0
  for let i = 1 to n:
    while(q > 0 并且 P[q + 1] !== T[i])
      q = next[q]
    if P[q + 1] == T[i]
      q = q + 1
    if (q == m)
      找到匹配位移 s = i
```

## 什么时候需要用到我们这节讲到的字符串匹配算法？

一般来说， 符合以下两个条件我们就应该考虑使用：

1. 是一个字符串匹配问题。 即你的算法中有一部分是**判断两个字符串是否相等**
2. 常规的线性字符串匹配会超时。

你可以把这个过程类比成： 如果遇到一个题目需要在线性表中搜索一个值， 那么我们可以将其存到哈希表中从而优化查询时间。

比如 [1316. 不同的循环子字符串](https://leetcode.cn/problems/distinct-echo-substrings/) 这道题，我们可以枚举所有的子字符串， 这需要平方的复杂度， 然后判断所有的字符串是否是”循环字符串”，这需要线性的时间。

我们可以采用类似 RK 的算法， 对原始字符串进行一个哈希编码， 然后使用类似前缀和的技巧从而可以在常数时间求出任意子串的哈希值， 然后我们通过哈希值进行匹配就可以将上面的线性匹配优化为常数匹配。

## 相关专题

### 子序列匹配

和字符串不同，一个字符串 t 是字符串 s 的子序列时，满足删除 s 中的若干字符（也可以不删除）后可以使得 t。比如 "abc" 是 "akbqc" 的子序列，但是 "abc" 却不是 "akbqc" 的子串。

那么第一个问题如何判断一个字符串 t 是否是另外一个字符串 s 的子序列呢？显然我们可以利用字符串匹配算法的思路，并加以调整。

具体地，我们初始化两个指针 i 和 j 分别指向 t 和 s 的开始位置， 接下来比较 t[i] 和 s[j]，如果可以匹配，我们**贪心**地将 i 移动一位。 如果我们通过这样的移动方式加 i 移动到 t 的末尾，那么就说明 t 为 s 的子序列。

> 这里贪心成功的原因是如果后面再进行匹配 t[i] 的话，一定不会比现在就匹配结果更好

```
def t(t, s):
  i = j = 0

  while i < len(t) and j < len(s):
    if t[i] == s[j]:
      i += 1
      if i == len(t): return True
    j += 1
  return False
```

推荐题目：[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

另外一个关于子序列的题型是，如果允许你删除 t 中的一个子串，从而使得 t 是 s 的子序列。那么问你需要删除的**最短**子串的长度。如果不需要删除，那返回 0 。

我们可以使用前缀+后缀的方式来解决。

```
pre = [len(s)+1] * (len(t))# pre[i] 表示匹配 s[:i] 需要的 s 的前缀长度
suf = [len(s)+1] * (len(t)) # suf[i] 表示匹配 s[i:] 需要的 s 的后缀长度
```

有了 pre 和 suf 数组，我们就可以枚举删除的子串长度 mid。对于给定的删除子串长度 mid， 我们继续枚举删除的位置 i。

```
def can(mid):
    for i in range(len(t)-mid+1):
        # [i: i+ mid) 被删除掉了，因此不需要覆盖，也就是说需要覆盖的是 [0, i) + [i+mid, len(t))
        if pre[i] + suf[i+mid] <= len(s): return True # 一旦两者和大于 len(s) 意味着相交， 即不满足题意
    return False
```

那么如何求解 pre 和 suf 呢？和前面的子序列匹配类似，我们来看代码。 pre 和 suf 处理方式类似，看懂一个，另外一个就好懂了。

```
pre = [len(s)+1] * (len(t))# pre[i] 表示匹配 s[:i] 需要的 s 的前缀长度
suf = [len(s)+1] * (len(t)) # suf[i] 表示匹配 s[i:] 需要的 s 的后缀长度
i = 0
# 预处理 pre
for j in range(len(t)):
    while i < len(s) and s[i] != t[j]:
        i += 1
    if i < len(s):
        pre[j] = i + 1
        i += 1
pre = [0] + pre # 简化逻辑，在 pre 前面加一个 0
i = len(s) - 1
# 预处理 suf
for j in range(len(t)-1, -1, -1):
    while i > -1 and s[i] != t[j]:
        i -= 1
    if i > -1:
        suf[j] = len(s) - i
        i -= 1
suf += [0] # 简化逻辑，在 suff 后面加一个 0
```

推荐题目： [2565. 最少得分子序列](https://leetcode.cn/problems/subsequence-with-the-minimum-score/)

### 最长公共前缀

**前置知识：动态规划**

实际上我们也可以用最长公共前缀（LCP） 来解决这个问题。

lcp(i,j) 表示字符串 s 从下标 i 开始的后缀和从下标 j 开始的后缀之间的最长公共前缀，那么转移方程为：

```
if s[i] == s[j]: lcp(i, j) = lcp(i+1, j+1) + 1
else: lcp(i,j) = 0
```

注意到状态 lcp(i,j) 依赖于状态 lcp(i+1,j+1)，因此我们需要倒序枚举。

完整求解 lcp 的 Python 代码如下：

```
lcp = [[0] * (n + 1) for _ in range(n + 1)]  # lcp[i][j] 表示 s[i:] 和 s[j:] 的最长公共前缀
for i in range(n - 1, -1, -1):
    for j in range(n - 1, i, -1):
        if s[i] == s[j]:
            lcp[i][j] = lcp[i + 1][j + 1] + 1
```

题目推荐：

- [6195. 对字母串可执行的最大删除数](https://leetcode.cn/problems/maximum-deletions-on-a-string/)

PS: 这道题 n^3n3 的暴力 dp 可以直接莽出来，和使用 lcp 优化时间竟然差不多。 这其实是测试用例太水的原因。附下代码：

```
class Solution:
    def deleteString(self, s: str) -> int:
        n = len(s)
        lcp = [[0] * (n + 1) for _ in range(n + 1)]  # lcp[i][j] 表示 s[i:] 和 s[j:] 的最长公共前缀
        for i in range(n - 1, -1, -1):
            for j in range(n - 1, i, -1):
                if s[i] == s[j]:
                    lcp[i][j] = lcp[i + 1][j + 1] + 1
        @cache
        def dp(pos):
            if pos == n: return 0
            ans = 1
            for i in range(pos+1, n):
                if lcp[pos][i] >= i - pos:
                # 不使用 lcp 优化就注释掉上面的代码， 然后打开下面的代码即可
                # if s[pos:i] == s[i:i+i-pos]:
                    ans = max(ans, 1 + dp(i))
            return ans
        return dp(0)
```

## 总结

字符串匹配本质就是求一个模式串是否在主串中出现过，以及出现的具体位置。我们本章讲解了字符串匹配的三种常见方法：暴力法，RK 算法和 KMP 算法。

其中

- 暴力法简单直接
- RK 算法就是前面滑动窗口专题的应用，核心在于哈希函数的选择
- KMP 则是前面动态规划的应用，核心在于 next 数组的生成。

虽然本章是讲字符串的匹配，但是你可以将其进行简单的扩展，以实现知识的迁移。

比如给你两个数组 A 和 B，其中 A 为 [1,2,3,4,5] ，B 为 [2,8,9,10]。让你在 A 中 找到 B 的最长相似数组。其中相似数组指的是；如果数组 A[i], A[i+1] , ... A[j] 与 B[p], B[p+1] , ... B[q]，满足 A[i] == B[p] + x，A[i+1] == B[p+1] + x, .... A[j] == B[q] + x，其中 x 为任意数字。

这个题目可以将 A 和 B 做一个简单的变换，变换之后就可以看成是字符串匹配，即让你在 A 中找 B。

那么如何变化呢？答案是相邻项做差。

```
for i in range(1, len(A)):
  A[i] -= A[i-1]
  B[i] -= B[i-1]
```

经过这样的处理 A 和 B 就变为了：

```
A = [1,1,1,1,1]
B = [2,1,1,1]
```

可以看出除了首项外，A 和 B 相似数组的值是相同的。

我们先不看 A 和 B 的首项，这样的话我们只要在 A 中找到 [1,1,1] 就行了，最后在考虑首项即可。

此时我们就可以使用本章的方法来解决，比如 RK 算法（选择一个合适的哈希函数即可）。

## 总结

本节讲述了三种字符串匹配算法，分别为暴力匹配，RK（哈希匹配）和 KMP。

- 暴力解法必须要理解，但不推荐在做题中使用，除非数据量足够小。
- 最最推荐掌握的是 RK（哈希匹配），不管是思想还是复杂度都非常优秀。
- KMP 作为拔高，有能力的同学可以掌握一下。如果仍然学有余力可以尝试下后面的扩展内容。

## 扩展

### 推荐加练

- [792. 匹配子序列的单词数](https://leetcode-cn.com/problems/number-of-matching-subsequences/) 这道题虽然不是求子串，而是子序列，算法也不能套用当前章。但是却和本章内容有关，大家可以结合练习。另外还可以顺便复习一下哈希表。 强烈推荐 🔥🔥🔥🔥

> 这道题能使用前缀树解决么？为什么？

- [1392. 最长快乐前缀](https://leetcode.cn/problems/longest-happy-prefix/) 这道题虽然不是直接的字符串匹配，但是我们需要判断前缀和后缀这”两个字符串是否相等“，其本质也是字符串匹配。 强烈推荐 🔥🔥🔥🔥

其他推荐题目（学有余力的可以尝试）：

- https://leetcode-cn.com/problems/longest-duplicate-substring/
- https://leetcode-cn.com/problems/shortest-palindrome/
- https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/
- https://leetcode-cn.com/problems/longest-chunked-palindrome-decomposition/
- https://leetcode-cn.com/problems/distinct-echo-substrings/

### 基于有限自动机的字符串匹配

这个算法仅限了解即可，这里不做展开，感兴趣可以参考 [Finite Automata algorithm for Pattern Searching](https://www.geeksforgeeks.org/finite-automata-algorithm-for-pattern-searching/)

### Z 函数（扩展 KMP）

- [oi-wiki](https://oi-wiki.org/string/z-func/#_2) 相关题目 [6036. 构造字符串的总得分和](https://leetcode-cn.com/problems/sum-of-scores-of-built-strings/)

## 参考

- [油管 KMP 讲解](https://www.youtube.com/watch?v=GTJr8OvyEVQ)(需翻墙)
- [维基百科](https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法)
- [从头到尾彻底理解 KMP](https://blog.csdn.net/v_JULY_v/article/details/7041827)
- [Finite Automata algorithm for Pattern Searching](https://www.geeksforgeeks.org/finite-automata-algorithm-for-pattern-searching/)

