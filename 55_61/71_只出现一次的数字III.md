# 260. 只出现一次的数字 III

## 题目地址（260. 只出现一次的数字 III）

https://leetcode-cn.com/problems/single-number-iii/

## 标签

- 位运算

## 难度

- 中等

## 入选理由

1. 位运算基本是两者题型。 一种是直接考察位运算基础知识和基础 api 操作，另一种是实际应用，这里的应用又以状压压缩为主。因此第一道就是一个位运算的基本题目，另外我总结了好几道基础位运算题目， 推荐大家私底下都看看。明天我们是一个状态压缩应用题。

## 前置知识

- 位运算
- 数组
- 哈希表

## 分析

这个题可以很直观的用哈希表来做，遍历一遍数组存入哈希表，再遍历一遍 key，找到 value 为 1 的那两个数就是最后答案，该解决方案的时间复杂度是线性，但是空间复杂度是O(keys)O(keys)，不符合题意。

其实做过该系列的前两道题的应该都知道，本题可以巧用位运算的方式来实现O(1)O(1)空间复杂度，再具体来说使用到了异或(xor)的性质(这个要多做题总结，而不是第一眼看到题就能想出来用位运算)。

首先来再复习一下 xor 的主要性质

```python
0 xor 1 = 1    0 xor 0 = 0
1 xor 1 = 0    1 xor 0 = 1
也就是说当比较的两个bit不同时，xor的结果才为1

a xor b = b xor a  满足交换律
a xor a = 0        与自身异或为0
```

也就是说，如果两个数相同那么必定 xor 没了，而该题说只有两个数出现一次，其他都是两次，再利用 0 xor 1 = 1 这条，可得如下解法：

- 将 nums 中所有数异或起来得到数 x，x 必定不为 0，因为相同的两个数都约掉了，相当于那两个只出现了一次的数进行 xor。
- 随便找一个 x 的 bit 为 1 的位置，为 1 就代表这两个出现一次的数在该位置的 bit 不同。
- 这样就可以根据这个为 1 的 bit 位来将原问题分解为两个子问题，子问题的定义是：给定一个数组，该数组只有一个数出现一次，其他数都出现两次。
- 这样就转换为基本的找出只出现一次数的问题了，直接将这个数组所有元素 xor 起来得到的就是答案。
- 为方便求解，本题使用的是低位最早出现 1 的位置。

Python Code：

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        xor = a = b = 0
        right_bit = 1
        length = len(nums)
        for i in nums:
            xor ^= i
        while right_bit & xor == 0:
            right_bit <<= 1
        for i in nums:
            if right_bit & i:
                a ^= i
            else:
                b ^= i
        return [a, b]
```

### 复杂度分析

设：N个数

时间复杂度：O(N)

空间复杂度：O(1)
